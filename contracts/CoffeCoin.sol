// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

/**
 * @author Mariosso
 * @title CoffeCoin (ERC20)
 * @notice This contract allows for the creation and management of CoffeCoin (CFC) tokens. It allows the deployer
 * to set maximum total supply and maximum supply for the allowlist at the deployment.
 *
 * Ownable: allows the owner to set some functions to be callable by only owner. Also allows the owner to
 * transfer ownership of the contract.
 *
 * Merkle Tree: allowlisted addreses and their mint amounts are managed by Merkle Tree. The root and the proofs
 * for the allowlist are generated by the scripts in scripts folder. The root of the tree can be updated by the
 * deployer after deployment.
 *
 * BitMaps: contract uses BitMaps for efficient tracking of claimed allowlist tokens.
 *
 */

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {BitMaps} from "@openzeppelin/contracts/utils/structs/BitMaps.sol";

contract CoffeCoin is ERC20, Ownable {
    BitMaps.BitMap private allowList;

    /////////
    // Errors
    /////////
    error NotAllowlisted();
    error YouHaveExceededMaxSupply(uint256);
    error WrongMaxAmountAllowlist();
    error AlreadyClaimed();

    //////////////////
    // State variables
    //////////////////
    bytes32 private s_merkleRoot;
    uint256 private immutable i_maxSupply;

    ////////////
    // Functions
    ////////////
    /**
     * @dev Creates an ERC20 token with name and symbol and mints (maxSupply - maxSupplyAllowlist) amount of
     * tokens.
     * @param _maxSupply the maximum amount of tokens that can be minted.
     * @param _maxSupplyAllowlist the maximum amount of tokens that can be minted for the allowlist. Make sure
     * that the sum of token amounts in Merkle Tree is the same as the _maxSupplyAllowlist.
     */
    constructor(uint256 _maxSupply, uint256 _maxSupplyAllowlist) ERC20("CoffeCoin", "CFC") {
        if (_maxSupplyAllowlist == 0 || _maxSupplyAllowlist >= _maxSupply) {
            revert WrongMaxAmountAllowlist();
        }
        _mint(msg.sender, _maxSupply - _maxSupplyAllowlist);
        i_maxSupply = _maxSupply;
    }

    /**
     * @dev lets the allowlisted addresses to mint the given amount of tokens, but only with vali proof and index.
     * @param _proof the Merkle Tree proof needed for the mint - generated by the script.
     * @param _index the index of the address.
     * @param _amount the amount of tokens to mint.
     */
    function mintTokensAllowlist(bytes32[] memory _proof, uint256 _index, uint256 _amount) public {
        // check if already claimed
        if (BitMaps.get(allowList, _index)) {
            revert AlreadyClaimed();
        }
        if (totalSupply() + _amount > i_maxSupply) {
            revert YouHaveExceededMaxSupply(i_maxSupply);
        }
        verify(_proof, msg.sender, _index, _amount);

        // set as claimed
        BitMaps.setTo(allowList, _index, true);
        _mint(msg.sender, _amount);
    }

    /**
     * @dev verifies if the address is allowlisted.
     */
    function verify(
        bytes32[] memory proof,
        address addr,
        uint256 index,
        uint256 amount
    ) public view {
        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(addr, index, amount))));
        if (!MerkleProof.verify(proof, s_merkleRoot, leaf)) {
            revert NotAllowlisted();
        }
    }

    /**
     * @dev updates the Merkle root. Can be called only by Owner.
     * @param _root the updated Merkle root.
     */
    function updateMerkleRoot(bytes32 _root) external onlyOwner {
        s_merkleRoot = _root;
    }

    // Getter functions
    function getRoot() public view returns (bytes32) {
        return s_merkleRoot;
    }

    function getMaxSupply() public view returns (uint256) {
        return i_maxSupply;
    }

    function getBitMaps(uint256 _index) public view returns (bool) {
        return BitMaps.get(allowList, _index);
    }
}
